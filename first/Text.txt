+ 1. Победить realloc
+ 2. Разобраться с потоками
+ 2.0. Разбить на потоки
+ 2.1. Количество ядер
+ 2.2. Объединить все ноды
+ 3. Сделать разбивалку по нодам separate
+ 3.1. Найти центры (добавить информацию в бранчи, указатели на листья)
+ 3.1.1. Выделить центры в струтуры, чтобы легче было сортировать
+ 3.2. Отсортировать центры по x или y (http://algolist.manual.ru/sort/quick_sort.php)
http://www.c-cpp.ru/content/qsort
http://www.cyberforum.ru/c-beginners/thread388245.html
http://www.cyberforum.ru/cpp-beginners/thread27084.html - quick sort
+ 3.3. Применить ко всем нодам (повторить необходимое количество раз)
+ 3.4. Порезать на необходимые части по кличеству листьев
+ 3.5. Когда разрезали на необходимое количество скопировать отдельно в общие куски памяти по веткам
+ 3.5.1. Дополнить структуры сортировки флагом отвечающим за признак переноса по веткам
+ 3.5.2. Скорее вссего флаг не нужен. Убрать.
+ 3.6. В каждой ветке пересчитать границы и обновить
+ 3.7. Сделать разбивку ветвей
+ 3.8. Сделать разбивку нодов
+ 3.8.1. Определить центры
+ 3.8.2. Порезать на ноды ветки
+ 3.8.3. Порезать на ноды ноды :)
++ 4. (отмена из-за 5) Оптимизировать алгоритм первого прохода и убрали лишние if
+ 5. Убрать первый проход и заменить на копирование в главный нод, расчёт центров и поиск границ
? 6. Подумать как дополнительно разбить если из-за большого объекта сильно расширились границы и это привело к попаданию большого количества объектов.
(в принципе не должно мешать, т.к. лишние надо проверить, что откидываются)
+ 7. Сделать поиск
8. Сравнить два поиска (стандартный оригинал и текущий)
+ 9. В generate случайным образом рассортировать массив
+ 10. Разобраться с выделением памяти в потоках. Быстрее начальное выделение в одном потоке или в нескольких. Получилось, что в потоках быстрее.
11. Поменять indexer на __int64 и устранить все warnings.
12. Убрать указатель на указатель. Всё равно сплошной кусок памяти.
+- 13. Проверить del_root на правильное освобождение памяти
+ 14. Разобраться с mem_size в del_root.
15. Освобождение память first_branch разобраться.
16. Разделение больших объектов в бранчах, для более быстрого расчёта. Или для того, чтобы не потерялось. Решение: посчитать длину и проверять её до проверки на расстояние до точек.
+ 17. Убрать странности.
+ 18. Сделать компиляию под linux.
+ 19. Полечить потоки под linux.
+ 20. Сделать многопоточный тест.
+ 21. Сделать границы
22. Выдавать список объектов в границах
23. Выдавать объекты наиближайшие в количестве n штук
+ 24. Убрать main и перенести в test
+ 25. Сделать первоначальное определение памяти для выделения
26. Многопоточность сортировки при построении дерева

/GS /GL /W3 /Gy /Zc:wchar_t /Zi /Gm- /O2 /sdl /Fd"x64\Release\vc140.pdb" /Zc:inline /fp:precise /D "_WIN" /D "NOMINMAX" /D "NDEBUG" /D "_CONSOLE" /D "_UNICODE" /D "UNICODE" /errorReport:prompt /WX- /Zc:forScope /Gd /Oi /MD /Fa"x64\Release\" /EHsc /nologo /Fo"x64\Release\" /Ot /Fp"x64\Release\first.pch" 
/OUT:"C:\projects\first\x64\Release\first.exe" /MANIFEST /LTCG:incremental /NXCOMPAT /PDB:"C:\projects\first\x64\Release\first.pdb" /DYNAMICBASE "kernel32.lib" "user32.lib" "gdi32.lib" "winspool.lib" "comdlg32.lib" "advapi32.lib" "shell32.lib" "ole32.lib" "oleaut32.lib" "uuid.lib" "odbc32.lib" "odbccp32.lib" /MACHINE:X64 /OPT:REF /INCREMENTAL:NO /PGD:"C:\projects\first\x64\Release\first.pgd" /SUBSYSTEM:CONSOLE /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /ManifestFile:"x64\Release\first.exe.intermediate.manifest" /OPT:ICF /ERRORREPORT:PROMPT /NOLOGO /TLBID:1
